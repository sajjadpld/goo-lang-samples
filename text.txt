command:
    go mod init <module-path>

    create a new module
    module path can be a repository path like github/sajjadpld/test

    it make go.mod file


-------------------------------------------------------------------------------

all our code must be in a package.
in go files at the begining add this:

package main

the first statment in Go file must be package name.

--------------------------------------------------------------------------------

func main(){}

this is a Go project entery point.

a application must have a main function or an entery point only

--------------------------------------------------------------------------------

for importing packages use:

import "fmt"

or

import (
    fmt
)

now we imported fmt package

------------------------------------------------------------------------------------

a package is a collection of source files

---------------------------------------------------------------------------------

for running a Go file, we must run below command:
go run file_name.go

-------------------------------------------------------------------------------------

a simple hello world app

package main

import "fmt"

func main(){
	fmt.Println("hello world")
}


-----------------------------------------------------------------------------------------

variable declaration:

var name = "sajjad"

or

name := "sajjad"

var i, j = 1, 2
or
var i, j int = 1, 2
or
c, python, java := true, false, "no!"

or this way:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe bool = false
	MaxInt uint64 = 1<<64 - 1
	Z 	complex128 = cmplx.Sqrt(-5 + 12i) 
)


func main (){
	fmt.Printf("Type: %T Value %v \n", ToBe, ToBe)
	fmt.Printf("Type: %T Value %v \n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value %v \n", Z, Z)
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

------------------------------------------------------------------------------------------

variables and imported package must be use, if you dont use them, you get compile error

------------------------------------------------------------------------------------------

declar a constant:

const age = 24

Constants can be character, string, boolean, or numeric values.

Constants cannot be declared using the := syntax.

const (
	c1 = 24
	c2 = 85
)

--------------------------------------------------------------------------------------------

sample code for formatting output:

++++++++++++++++++++++++++
package main

import "fmt"

func main() {

	var name = "sajjad"
	family := "PLD"

	const age = 24

	fmt.Printf("Hi, my name is %v and my last name is %v, im %v years old", name, family, age)
}
+++++++++++++++++++++++++++++++

output is :
Hi, my name is sajjad and my last name is PLD, im 24 years old

--------------------------------------------------------------------------------------------

for initial an variable for later, we must declare the variable type:

	var fatherName string

	fatherName = "Mahmoud"

	fmt.Println(fatherName)

--------------------------------------------------------------------------------------------

for print variable type:

fmt.Printf("the type of fatherName is %T\n", fatherName)

%T is for getting variable Type

--------------------------------------------------------------------------------------------------

you can write these too:

var v1 int = 85
const c1 string = "sajjad"

these are as same as below:

var v1 = 85
const c1 = "sajjad"

or for var is:
v1 := 85

-----------------------------------------------------------------------------------------------------

compare to Java data type:

Go          Java
int8    =>  byte
int16    =>  short
int32    =>  int
int64    =>  long

Go          Java
uint8    =>  ubyte
uint16    =>  ushort
uint32    =>  uint
uint64    =>  ulong

int and uint are depend on system architect, if system is 32 bit, it's 32 and if 64 bit, it's 64

-----------------------------------------------------------------------------------------------------

pointers in Go

	var fatherName string

	fatherName = "Mahmoud"

	fmt.Println(fatherName)

	fmt.Println(&fatherName)

variable address to its value in memory (pointer) in Go is "&"

the output is:
Mahmoud
0xc000046290

--------------------------------------------------------------------------------------------------------

for getting user input sample code:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
package main

import "fmt"

func main(){
	var gfName string
	fmt.Scan(&gfName)

	fmt.Printf("your gir friend name is %v", gfName)
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

---------------------------------------------------------------------------------------------------------

in Go arrays are fixed size

for declare an arraye use this:
++++++++++++++++++++++++++++++++++++++++++++++++
	var books = [3]string {"a","b","c"}

	fmt.Println(books)
+++++++++++++++++++++++++++++++++++++++++++++++++

the output is :
[a b c]

---------------------------------------------------------------------------------------------------------

for declaring empty array and fill array index use this:
+++++++++++++++++++++++++++++++++++++++++++++
	var books [3]string

	books[0] = "a"
	books[1] = "b"
	books[2] = "c"

	fmt.Println(books)
+++++++++++++++++++++++++++++++++++++++++++++

the output is :
[a b c]

-----------------------------------------------------------------------------------------------------------

for getting arraye size or length use this:

len(array)


this function is use for array and slice and strings.

-----------------------------------------------------------------------------------------------------------

when we dont know the size of the array for declaration array, we can use slice.
slice basicly is an abstraction of anj array, so it uses the array type under the hood but has dynamic size.

++++++++++++++++++++++++++++++++++++++++++++++++++++++
	var books []string

	books = append(books, "a")
	books = append(books, "b")
	books = append(books, "c")

	fmt.Println(books)
	fmt.Println(books[0])
	fmt.Println(len(books))
+++++++++++++++++++++++++++++++++++++++++++++++++++++++

or use this instead of first line:

books := []string{}


we can slice an array indices like this:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

primes := [6]int{2, 3, 5, 7, 11, 13}

fmt.Println(primes[1:4])

++++++++++++++++++++++++++++++++++++++++++++++++++++++++
A slice is formed by specifying two indices, a low and high bound, separated by a colon:
primes[low : high]
This selects a half-open range which includes the first element, but excludes the last one.
the output is:
[3 5 7]
output type is array

these slice expressions are equivalent:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
var a [10]int

a[0:10]
a[:10]
a[0:]
a[:]

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
The default is zero for the low bound and the length of the slice for the high bound.


A slice does not store any data, it just describes a section of an underlying array.

Changing the elements of a slice modifies the corresponding elements of its underlying array.

Other slices that share the same underlying array will see those changes.

A slice has both a length and a capacity.

The length of a slice is the number of elements it contains.

The capacity of a slice is the number of elements in the underlying array, counting from the first element in the slice.

The length and capacity of a slice s can be obtained using the expressions len(s) and cap(s).


for making an slice we can use both 2 ways:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

var sl []string

or sl := make([]string, 0)

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
make() second param in length and the third param is capacity.

-----------------------------------------------------------------------------------------------------------------

in Go we jus have "for" for loop.
no "while", "do while" and "foreach"!

for declar a simple loop:
+++++++++++++++++++++++++++++++++
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
+++++++++++++++++++++++++++++++++

for declare an infinite loop:

++++++++++++++++++++++++++++++++++++
	for {
		fmt.Println("line")
	}
++++++++++++++++++++++++++++++++++++

condition in loop:

+++++++++++++++++++++++++++++++++++++

	for condition {
		//code
	}
++++++++++++++++++++++++++++++++++++
sample:
+++++++++++++++++++++++++++++++++++++
	sum := 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
+++++++++++++++++++++++++++++++++++++
or
+++++++++++++++++++++++++++++++++++++++++
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
+++++++++++++++++++++++++++++++++++++++++

----------------------------------------------------------------------------------------------------------------

"rage" iterates over elements for different data structures (so not only arrayes and slices). for arrayes and slices, "range" provides the "index" and "value" for each element.

+++++++++++++++++++++++++
	var books = [8]string {"a", "b","c", "d","e", "f","g", "h"}

	for index, value := range books {
		fmt.Println(index, value)
	}
++++++++++++++++++++++++++++

the output is :
0 a
1 b
2 c
3 d
4 e
5 f
6 g
7 h


you can ignore unuse variable:

+++++++++++++++++++++++++
	var books = [8]string {"a", "b","c", "d","e", "f","g", "h"}

	for _, value := range books {
		fmt.Println(value)
	}
++++++++++++++++++++++++++++

or

+++++++++++++++++++++++++
	var books = [8]string {"a", "b","c", "d","e", "f","g", "h"}

	for index, _ := range books {
		fmt.Println(index)
	}
++++++++++++++++++++++++++++

------------------------------------------------------------------------------------------------------------------------

strings.Fields("str with space")

it spilite string by spaces and return an array

++++++++++++++++++++++++++++++++++++++++++++++++++++
package main

import (
	"fmt"
	"strings"
)

func main() {
	str := "my name is sajjad"

	fmt.Println(strings.Fields(str))
}
++++++++++++++++++++++++++++++++++++++++++++++++++
the output is :
[my name is sajjad]

---------------------------------------------------------------------------------------------------------------------------

condition:

if condition {
	//code
} else if condition {
	//code
} else {
	//code
}


Like for, the if statement can start with a short statement to execute before the condition.

Variables declared by the statement are only in scope until the end of the if.

+++++++++++++++++++++++++++++++++++++++++++++
func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}
+++++++++++++++++++++++++++++++++++++++++++++


-----------------------------------------------------------------------------------------------------------------------------------


checking string contains and another string:

+++++++++++++++++++++++++++++++++
package main

import (
	"fmt"
	"strings"
)

func main() {
	str := "my name is sajjad"

	fmt.Println(strings.Contains(str, "sajjad"))
}
+++++++++++++++++++++++++++++++++++++++++++++

----------------------------------------------------------------------------------------------------------------------------------

switch case:

switch variable {
	case expretion:
		//code
	case expretion:
		//code
	case expretion:
		//code
	case expretion:
		//code
	case expretion:
		//code
	default:
		//code
}

switch city {
	case "city1":
		//code
	case "city2", "city3":
		//code this is ||
	case "city4", "city5":
		//code this is ||
	case "city6":
		//code
	default:
		//code
}

Switch cases evaluate cases from top to bottom, stopping when a case succeeds.

-----------------------------------------------------------------------------------------------------------------

function:

with no param:

+++++++++++++++++++++++++++++
func fn(){
	//code
}
+++++++++++++++++++++++++++++
use:
fn()

with string param:
+++++++++++++++++++++++++++++
func fn(p1 string){
	fmt.Println(p1)
}
+++++++++++++++++++++++++++++
use:
fn("sajjad")

with arraye param:
+++++++++++++++++++++++++++++
func fn(arr []int){
	fmt.Println(arr)
}
++++++++++++++++++++++++++++
use:
var arr = [5]int {1,2,3,4,5}
fn(arr)

with return:
+++++++++++++++++
func fn() string{
	str := "sajjad"

	return str
}
++++++++++++++++++
use:
str := fn()

return multiple values:
++++++++++++++++++++++++++
func fn() (int, string){
	in := 24
	str := "sajjad"

	return in, str
}
++++++++++++++++++++++++
use:
in, st := fn()

named return values:
++++++++++++++++++++++++++
func split(sum int) (x, y int) {
	x = sum * 4 / 9
	y = sum - x
	return
}
++++++++++++++++++++++++
A return statement without arguments returns the named return values. This is known as a "naked" return. They can harm readability in longer functions.


function parameter can be another function!
++++++++++++++++++++++++++++++++++++++++++++++

func compute(fn func(float64, float64) float64) float64 {
	return fn(3, 4)
}

func main() {
	hypot := func(x, y float64) float64 {
		return math.Sqrt(x*x + y*y)
	}
	fmt.Println(hypot(5, 12))

	fmt.Println(compute(hypot))
}

++++++++++++++++++++++++++++++++++++++++++++++
output:
13
5


Function closures:
Go functions may be closures. A closure is a function value that references variables from outside its body. The function may access and assign to the referenced variables; in this sense the function is "bound" to the variables.

For example, the adder function returns a closure. Each closure is bound to its own sum variable.
++++++++++++++++++++++++++++++++++++++++++++++++++

func adder() func(int) int {
	sum := 0
	return func(x int) int {
		sum += x
		return sum
	}
}

func main() {
	pos, neg := adder(), adder()
	for i := 0; i < 10; i++ {
		fmt.Println(
			pos(i),
			neg(-2*i),
		)
	}
}

++++++++++++++++++++++++++++++++++++++++++++++++++
output:
0 0
1 -2
3 -6
6 -12
10 -20
15 -30
21 -42
28 -56
36 -72
45 -90



-------------------------------------------------------------------------

package level variables are variables that declared in package (not function) and can access in all functions:

++++++++++++++++++++++++
package main

import (
	"fmt"
)

var name string = "sajjad"

func main() {
	fmt.Println(name)
}
+++++++++++++++++++++++++++++

define variables as "local" as possible.

-------------------------------------------------------------------------------

packages:

Go programes are orgnized into packages.
A package is a collection of Go files.

Variables and functions defiened outside any function (package level variables) can be accessed in all other files within the same package.

sample:

helper.go:
++++++++++++++++++
package main

import "strings"

func validateEmain() bool{
	return strings.Contains(email, "@")
}
+++++++++++++++++++

main.go:
+++++++++++++++++++
package main

import (
	"fmt"
)

var email string = "sajjad@gmailcom"

func main() {
	fmt.Println(validateEmain())
}
+++++++++++++++++++++++

for run project:
go run main.go helper.go
or
go run .

this sample was for same named package(main) or same package.
for multi package we must do this:

run this:
go mod init <module-path>

it makes go.mod file and <module-path> is or module name and for importing we use its name.

for make a variable or function public in Go, we must make first letter of the name captal, like:
func validateEmain(){...}	=>	func ValidateEmain(){...}.
put package files in same name directory.

now the structure is:

go.mod:
++++++++++++++++++++++++++
module booking-app

go 1.13
++++++++++++++++++++++++++

helper/helper.go
+++++++++++++++++++++++++++
package helper

import "strings"

func ValidateEmain(email string) bool{
	return strings.Contains(email, "@")
}
+++++++++++++++++++++++++++

main.go
++++++++++++++++++++++++++
package main

import (
	"fmt"
	"goo-lang-samples/helper"
)

var email string = "sajjad@gmailcom"

func main() {
	fmt.Println(helper.ValidateEmain(email))
}
++++++++++++++++++++++++++

-----------------------------------------------------------------------

variable scopes:

we declare variables in 3 mode:
local
package
global

local: 
we declar variables in a function and can be used only in that function.
we declar variables in a block of code like for, if, else and can be used only in that block.

package:
we declar variables outof function, in package and can be used in all the same package.

global:
we declar variables outside all functions (package variable) with uppercase first letter and this can be used everywhere across all packages.

--------------------------------------------------------------------------

maps:

unique keys to value.
all keys have the same data type.
all values have the same data type.

+++++++++++++++++++++++++++++++++++++
var userData = map[string]string
+++++++++++++++++++++++++++++++++++++

map[string]	=>	the key data type is string
string	=>	the value data type is string

for create empty map:
++++++++++++++++++++++++++++++++++++++++
var userData = make(map[string]string)
++++++++++++++++++++++++++++++++++++++++

for adding do this:
++++++++++++++++++++++++++++++++++++++++++
	var userData = make(map[string]string)

	userData["userName"] = "sajjadpld"
	userData["password"] = "1234"

	fmt.Println(userData)
++++++++++++++++++++++++++++++++++++++++++

the output is:
map[password:1234 userName:sajjadpld]

for gett specific key:
++++++++++++++++++++++++++++++++++++
fmt.Println(userData["userName"])
+++++++++++++++++++++++++++++++++++++

for declare an array of map:
++++++++++++++++++++++++++++++++++++
var books = make([]map[string]string, 0)
++++++++++++++++++++++++++++++++++++
the make function second param can be any number, because it makes slice and the size of slice increse.


++++++++++++++++++++++++++++++++++++++++++++++++++++++

type Vertex struct {
	Lat, Long float64
}

var m map[string]Vertex

func main() {
	m = make(map[string]Vertex)
	m["Bell Labs"] = Vertex{
		40.68433, -74.39967,
	}
	fmt.Println(m["Bell Labs"])
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++
output:
{40.68433 -74.39967}


+++++++++++++++++++++++++++++++++++++++++++++++++++++

type Vertex struct {
	Lat, Long float64
}

var m = map[string]Vertex{
	"Bell Labs": Vertex{
		40.68433, -74.39967,
	},
	"Google": Vertex{
		37.42202, -122.08408,
	},
}

func main() {
	fmt.Println(m)
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++
output:
map[Bell Labs:{40.68433 -74.39967} Google:{37.42202 -122.08408}]

this is same :

+++++++++++++++++++++++++++++++++++++++++++++++++++++
var m = map[string]Vertex{
	"Bell Labs": {40.68433, -74.39967},
	"Google":    {37.42202, -122.08408},
}
+++++++++++++++++++++++++++++++++++++++++++++++++++++

for delete map key use delete(map_name, key).

Test that a key is present with a two-value assignment:
elem, ok = m[key]
If key is in m, ok is true. If not, ok is false.

If key is not in the map, then elem is the zero value for the map's element type.

++++++++++++++++++++++++++++++++++++++++++++++++++++++

func main() {
	m := make(map[string]int)

	m["Answer"] = 42
	fmt.Println("The value:", m["Answer"])

	m["Answer"] = 48
	fmt.Println("The value:", m["Answer"])

	delete(m, "Answer")
	fmt.Println("The value:", m["Answer"])

	v, ok := m["Answer"]
	fmt.Println("The value:", v, "Present?", ok)
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++
output:
The value: 42
The value: 48
The value: 0
The value: 0 Present? false



--------------------------------------------------------------------------------------------------------------

struct:
struct is like class OOP languages but its different with it.
it's like a lighweight class wich dosen't support inheritance.
it can contains mixed data types and define a structure of data.

++++++++++++++++++++++++++++++++
package main

import (
	"fmt"
)

type userData struct {
	name  string
	email string
}

func main() {
	data := userData{"sajjad", "1234"}
	fmt.Println(data)
}
++++++++++++++++++++++++++++++++

for initiate new struct you can use:
+++++++++++++++++++++++++++++++++
data := userData{"sajjad", "1234"}
+++++++++++++++++++++++++++++++++
or
+++++++++++++++++++++++++++++++++++
data := userData{name: "sajjad", email: "1234"}
+++++++++++++++++++++++++++++++++++

for making an array of structs you can use like maps:
+++++++++++++++++++++++++++++++++++
var books = make([]userData, 0)
+++++++++++++++++++++++++++++++++++

for getting an item from struct do this:
++++++++++++++++++++++++++++++++
fmt.Println(data.email)
++++++++++++++++++++++++++++++++

for editing struct do:
++++++++++++++++++++++++++++++++
data.email = "email@mm.com"
++++++++++++++++++++++++++++++++

-----------------------------------------------------------------------------------------------------

for installing new package run below command:

go get <package-address>

-----------------------------------------------------------------------------------------------------

multiple string lines in go:

str := `Select count(e.id) as count
    FROM event AS e
	INNER JOIN event_participants AS ep ON e.id = ep.eventFK
	LEFT JOIN participant AS p ON ep.participantFK = p.id
	LEFT JOIN tournament_stage AS ts ON ts.id = e.tournament_stageFK
	LEFT JOIN tournament AS t ON t.id = ts.tournamentFK
	LEFT JOIN tournament_template AS tt ON tt.id = t.tournament_templateFK
	LEFT JOIN property AS e_prop ON e_prop.objectFK = e.id AND e_prop.object = "event" AND e_prop.type = "metadata"
	LEFT JOIN lineup AS l ON ep.id = l.event_participantsFK
    WHERE
	tt.sportFK = 1 AND
	e.status_type = "finished" AND
    e.del = "no" AND
    p.del = "no"
    `

-----------------------------------------------------------------------------------------------------
defer:

A defer statement defers the execution of a function until the surrounding function returns.

The deferred call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.

+++++++++++++++++++++++++++++++++++++++++++++++++
package main

import "fmt"

func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
+++++++++++++++++++++++++++++++++++++++++++++++++
output:
hello
world


Deferred function calls are pushed onto a stack. When a function returns, its deferred calls are executed in last-in-first-out order.
++++++++++++++++++++++++++++++++++++++++++++++++
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
++++++++++++++++++++++++++++++++++++++++++++++++
output:
counting
done
9
8
7
6
5
4
3
2
1
0

--------------------------------------------------------------------------------------------------------------------

pointers:

A pointer holds the memory address of a value.
The type *T is a pointer to a T value. for function params we can use this:
++++++++++++++++++++++++++++++++++++++
package main

import "fmt"

func ptr(p *int) {
	*p = 24
}

func main() {
	i := 42

	fmt.Println(i)
	ptr(&i)
	fmt.Println(i)
}
++++++++++++++++++++++++++++++++++++++
output:
42
24

The & operator generates a pointer to its operand. & return the variable memory address and we can put it in a variable and with * we can get the value of the memory address.
+++++++++++++++++++++++++++++++++++++++
	i, j := 42, 2701

	p := &i         // point to i
	fmt.Println(*p) // read i through the pointer
	fmt.Println(p)
	*p = 21        // set i through the pointer
	fmt.Println(i) // see the new value of i

	p = &j         // point to j
	*p = *p / 37   // divide j through the pointer
	fmt.Println(j) // see the new value of j
+++++++++++++++++++++++++++++++++++++++
output:
42
0xc0000140b0
21
73

we can use pointer for struct:
++++++++++++++++++++++++++++++++++++++++++++++++++
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 3
	fmt.Println(v)
}
++++++++++++++++++++++++++++++++++++++++++++++++++
output:
{3 2}

instead if p.X = 3 we can use (*p).X = 3.
To access the field X of a struct when we have the struct pointer p we could write (*p).X. 
However, that notation is cumbersome, so the language permits us instead to write just p.X, without the explicit dereference.


these two code are same:
++++++++++++++++++++++++++++++++++++

i := 42
fmt.Println(*&i)

++++++++++++++++++++++++++++++++++++

++++++++++++++++++++++++++++++++++++

i := 42
fmt.Println(i)

++++++++++++++++++++++++++++++++++++

both output is 42 !

----------------------------------------------------------------------------------------------------------------------

Methods:
Go does not have classes. However, you can define methods on types.
A method is a function with a special receiver argument.
The receiver appears in its own argument list between the func keyword and the method name.
In this example, the Abs method has a receiver of type Vertex named v:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(v.Abs())
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++

above code function is:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

type Vertex struct {
	X, Y float64
}

func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	v := Vertex{3, 4}
	fmt.Println(Abs(v))
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++

You can declare a method on non-struct types, too.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

type MyFloat float64

func (f MyFloat) Abs() float64 {
	if f < 0 {
		return float64(-f)
	}
	return float64(f)
}

func main() {
	f := MyFloat(-math.Sqrt2)
	fmt.Println(f.Abs())
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++
In this example we see a numeric type MyFloat with an Abs method.

You can only declare a method with a receiver whose type is defined in the same package as the method. 
You cannot declare a method with a receiver whose type is defined in another package (which includes the built-in types such as int).


You can declare methods with pointer receivers.
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func (v *Vertex) Scale(f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	v.Scale(10)
	fmt.Println(v.Abs())
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Methods with pointer receivers can modify the value to which the receiver points (as Scale does here). 
Since methods often need to modify their receiver, pointer receivers are more common than value receivers.

above code function is:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

type Vertex struct {
	X, Y float64
}

func Abs(v Vertex) float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func Scale(v *Vertex, f float64) {
	v.X = v.X * f
	v.Y = v.Y * f
}

func main() {
	v := Vertex{3, 4}
	Scale(&v, 10)
	fmt.Println(Abs(v))
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++

There are two reasons to use a pointer receiver.
The first is so that the method can modify the value that its receiver points to.
The second is to avoid copying the value on each method call. This can be more efficient if the receiver is a large struct, for example.

In general, all methods on a given type should have either value or pointer receivers, but not a mixture of both.

----------------------------------------------------------------------------------------------------------------------

Interfaces:

An interface type is defined as a set of method signatures.
A value of interface type can hold any value that implements those methods.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++

type Abser interface {
	Abs() float64
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++

above code is declaring interface.

sample of usage is:
++++++++++++++++++++++++++++++++++++++++++++++++++++++

type Abser interface {
	Abs() float64
}

type Vertex struct {
	X, Y float64
}

func (v *Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	var a Abser
	v := Vertex{3, 4}

	a = &v // a *Vertex implements Abser

	fmt.Println(a.Abs())
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++
because Abs method is pointer method, we use "a = &v", if it was not pointer method we could use "a = v" or "a = &v" (both is valid for non pointer method):

++++++++++++++++++++++++++++++++++++++++++++++++++++++

type Abser interface {
	Abs() float64
}

type Vertex struct {
	X, Y float64
}

func (v Vertex) Abs() float64 {
	return math.Sqrt(v.X*v.X + v.Y*v.Y)
}

func main() {
	var a Abser
	v := Vertex{3, 4}

	a = v

	fmt.Println(a.Abs())
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++

another sample:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++

type I interface {
	M()
}

type T struct {
	S string
}

// This method means type T implements the interface I,
// but we don't need to explicitly declare that it does so.
func (t T) M() {
	fmt.Println(t.S)
}

func main() {
	var i I = T{"hello"}
	i.M()
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Calling a method on a nil interface is a run-time error because there is no type inside the interface tuple to indicate which concrete method to call.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++

type I interface {
	M()
}

func main() {
	var i I
	i.M()
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++
panic: runtime error!


The interface type that specifies zero methods is known as the empty interface:
var i interface{}

An empty interface may hold values of any type. (Every type implements at least zero methods.)
Empty interfaces are used by code that handles values of unknown type. For example, fmt.Print takes any number of arguments of type interface{}.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

func main() {
	var i interface{}
	fmt.Printf("(%v, %T)\n", i, i)

	i = 42
	fmt.Printf("(%v, %T)\n", i, i)

	i = "hello"
	fmt.Printf("(%v, %T)\n", i, i)
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
output:
(<nil>, <nil>)
(42, int)
(hello, string)


A type assertion provides access to an interface value's underlying concrete value.
"t := i.(T)"
This statement asserts that the interface value i holds the concrete type T and assigns the underlying T value to the variable t.

If i does not hold a T, the statement will trigger a panic.

To test whether an interface value holds a specific type, a type assertion can return two values: the underlying value and a boolean value that reports whether the assertion succeeded.
"t, ok := i.(T)"
If i holds a T, then t will be the underlying value and ok will be true.

If not, ok will be false and t will be the zero value of type T, and no panic occurs.

Note the similarity between this syntax and that of reading from a map.
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

func main() {
	var i interface{} = "hello"

	s := i.(string)
	fmt.Println(s)

	s, ok := i.(string)
	fmt.Println(s, ok)

	f, ok := i.(float64)
	fmt.Println(f, ok)

	f = i.(float64) // panic
	fmt.Println(f)
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
output:
hello
hello true
0 false
panic: interface conversion:..............

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

func do(i interface{}) {
	switch v := i.(type) {
	case int:
		fmt.Printf("Twice %v is %v\n", v, v*2)
	case string:
		fmt.Printf("%q is %v bytes long\n", v, len(v))
	default:
		fmt.Printf("I don't know about type %T!\n", v)
	}
}

func main() {
	do(21)
	do("hello")
	do(true)
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
output:
Twice 21 is 42
"hello" is 5 bytes long
I don't know about type bool!


One of the most ubiquitous interfaces is Stringer defined by the fmt package.
++++++++++++++++++++++++++++++++++

type Stringer interface {
    String() string
}

++++++++++++++++++++++++++++++++++
A Stringer is a type that can describe itself as a string. The fmt package (and many others) look for this interface to print values.

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

type Person struct {
	Name string
	Age  int
}

func (p Person) String() string {
	return fmt.Sprintf("%v (%v years)", p.Name, p.Age)
}

func main() {
	a := Person{"Arthur Dent", 42}
	z := Person{"Zaphod Beeblebrox", 9001}
	fmt.Println(a, z)
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
output:
Arthur Dent (42 years) Zaphod Beeblebrox (9001 years)


---------------------------------------------------------------------------------------------------------

Errors:
Go programs express error state with error values.

The error type is a built-in interface:
++++++++++++++++++++++++++++++++++++++++++

type error interface {
    Error() string
}

++++++++++++++++++++++++++++++++++++++++++

As with fmt.Stringer, the fmt package looks for the error interface when printing values.

Functions often return an error value, and calling code should handle errors by testing whether the error equals nil.
++++++++++++++++++++++++++++++++++++++++++

i, err := strconv.Atoi("42")
if err != nil {
    fmt.Printf("couldn't convert number: %v\n", err)
    return
}
fmt.Println("Converted integer:", i)

++++++++++++++++++++++++++++++++++++++++++

A nil error denotes success; a non-nil error denotes failure.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++

import (
	"fmt"
	"time"
)

type MyError struct {
	When time.Time
	What string
}

func (e *MyError) Error() string {
	return fmt.Sprintf("at %v, %s",
		e.When, e.What)
}

func run() error {
	return &MyError{
		time.Now(),
		"it didn't work",
	}
}

func main() {
	if err := run(); err != nil {
		fmt.Println(err)
	}
}

++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
output:
at 2009-11-10 23:00:00 +0000 UTC m=+0.000000001, it didn't work


-------------------------------------------------------------------------------------------------

Concurrency:

below code is a sync program:
+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"time"
)

func main() {
	now := time.Now()
	task1()
	task2()
	task3()
	task4()
	fmt.Println("finished at ", time.Since(now))
}

func task1() {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 1")
}

func task2() {
	time.Sleep(200 * time.Millisecond)

	fmt.Println("task 2")
}

func task3() {
	fmt.Println("task 3")
}

func task4() {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 4")
}

+++++++++++++++++++++++++++++++++++++++++++++++
output is:
task 1
task 2
task 3
task 4
finished at  400.863974ms

async code of above code is:
+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"time"
)

func main() {
	now := time.Now()
	go task1()
	go task2()
	go task3()
	go task4()
	fmt.Println("finished at ", time.Since(now))
}

func task1() {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 1")
}

func task2() {
	time.Sleep(200 * time.Millisecond)

	fmt.Println("task 2")
}

func task3() {
	fmt.Println("task 3")
}

func task4() {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 4")
}

+++++++++++++++++++++++++++++++++++++++++++++++
output is:
finished at  24.915µs

with "go" keyword we can have async running, but task 1 to 4 function code body dosen't run, 
because when the executer pointer when arive to the line that has "go" keyword, it makes a new thread and execution of that code run 
in that thread and its alive until the main thread (function main) execution is alive and its not finished.
for this reason, whene execution pointer arive to "go task1()", it makes a new thread for that and that thread wants to run task1() and execution pointer go to next line and make new thread
for "go task2()" until "go task4()" and after that its print mesaage and after that main function is done and its close and all thread will be exit of ther execution!
for fix this we must stop running of main thread untill all of goroutines (codes that run with "go" keyword) executed and after that execute rest of codes.
use "sync.WaitGroup" for fixing this:

+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"sync"
	"time"
)

var wg sync.WaitGroup

func main() {
	now := time.Now()

	wg.Add(4)

	go task1()
	go task2()
	go task3()
	go task4()

	wg.Wait()

	fmt.Println("finished at ", time.Since(now))
}

func task1() {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 1")

	wg.Done()
}

func task2() {
	time.Sleep(200 * time.Millisecond)

	fmt.Println("task 2")
	wg.Done()
}

func task3() {
	fmt.Println("task 3")
	wg.Done()
}

func task4() {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 4")
	wg.Done()
}

+++++++++++++++++++++++++++++++++++++++++++++++
output is:
task 3
task 1
task 4
task 2
finished at  200.377525ms

wg.Add(4) is 4, because we opened 4 goroutines and at the end of each goroutine execution we must cal wg.Done(). after calling goroutine we must call wg.Wait().
in other speache, when we use Add(N), in the background there is a variable with N value number. when we cal Done(), the variable value will decress 1, it will be N - 1.
in Wait(), the main thread will wait until variable value in background is 0.

we can write above code like this:

+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"sync"
	"time"
)

var wg sync.WaitGroup

func main() {
	now := time.Now()

	wg.Add(4)

	go func() {
		task1()
		wg.Done()
	}()

	go func() {
		task2()
		wg.Done()
	}()

	go func() {
		task3()
		wg.Done()
	}()

	go func() {
		task4()
		wg.Done()
	}()

	wg.Wait()

	fmt.Println("finished at ", time.Since(now))
}

func task1() {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 1")
}

func task2() {
	time.Sleep(200 * time.Millisecond)

	fmt.Println("task 2")
}

func task3() {
	fmt.Println("task 3")
}

func task4() {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 4")
}

+++++++++++++++++++++++++++++++++++++++++++++++
output is same az above code

it's better to write like this, don't add WaitGroup.Done() at the end of function code.

we can use channel for do exact above code:

+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"time"
)

func main() {
	now := time.Now()

	done := make(chan struct{})

	go task1(done)
	go task2(done)
	go task3(done)
	go task4(done)

	<-done
	<-done
	<-done
	<-done

	fmt.Println("finished at ", time.Since(now))
}

func task1(done chan struct{}) {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 1")

	done <- struct{}{}
}

func task2(done chan struct{}) {
	time.Sleep(200 * time.Millisecond)

	fmt.Println("task 2")

	done <- struct{}{}
}

func task3(done chan struct{}) {
	fmt.Println("task 3")

	done <- struct{}{}
}

func task4(done chan struct{}) {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 4")

	done <- struct{}{}
}


+++++++++++++++++++++++++++++++++++++++++++++++

we can write above code like this:

+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"time"
)

func main() {
	now := time.Now()

	done := make(chan struct{})

	go func() {
		task1()
		done <- struct{}{}
	}()

	go func() {
		task2()
		done <- struct{}{}
	}()

	go func() {
		task3()
		done <- struct{}{}
	}()

	go func() {
		task4()
		done <- struct{}{}
	}()

	<-done
	<-done
	<-done
	<-done

	fmt.Println("finished at ", time.Since(now))
}

func task1() {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 1")
}

func task2() {
	time.Sleep(200 * time.Millisecond)

	fmt.Println("task 2")
}

func task3() {
	fmt.Println("task 3")
}

func task4() {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 4")
}

+++++++++++++++++++++++++++++++++++++++++++++++

we make a channel with "make()" and at the end of execution of the thread code put value in channel by "<-".
for wait main thread we must use "<-channel". as same as count of goroutines we must do this.


this 2 types of code (WaitGroup and channel) are fork join model for concurrency.

we can pass WaitGroup variable to a function and use that (like channels that we passed to function):
+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"sync"
	"time"
)

func main() {
	now := time.Now()

	var wg sync.WaitGroup

	wg.Add(4)

	go task1(&wg)
	go task2(&wg)
	go task3(&wg)
	go task4(&wg)

	wg.Wait()

	fmt.Println("finished at ", time.Since(now))
}

func task1(wg *sync.WaitGroup) {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 1")

	wg.Done()
}

func task2(wg *sync.WaitGroup) {
	time.Sleep(200 * time.Millisecond)

	fmt.Println("task 2")

	wg.Done()
}

func task3(wg *sync.WaitGroup) {
	fmt.Println("task 3")

	wg.Done()
}

func task4(wg *sync.WaitGroup) {
	time.Sleep(100 * time.Millisecond)

	fmt.Println("task 4")

	wg.Done()
}

+++++++++++++++++++++++++++++++++++++++++++++++
unlike channel, which function param was value type, for WaitGroup function param must be pointer type! if you dont do this, you get panic (panic: sync: negative WaitGroup counter).



Deadlock:
when you add goroutine to your WaitGroup.Add() and never make new goroutine for that and wait for it, Deadlock happens!
this means that we are waiting on something which never happens!
+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"sync"
)

func main() {
	var wg sync.WaitGroup

	wg.Add(1)
	wg.Wait()

	fmt.Println("Deadlock happend")
}

+++++++++++++++++++++++++++++++++++++++++++++++
error is:
fatal error: all goroutines are asleep - deadlock!



negative WaitGroup counter:
when you Done more than Add() counts, this panic happen!
+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"sync"
)

func main() {
	var wg sync.WaitGroup

	wg.Done()
}

+++++++++++++++++++++++++++++++++++++++++++++++
error is:
panic: sync: negative WaitGroup counter

never Add befor goroutine execute finished:
+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"sync"
)

func main() {
	var wg sync.WaitGroup

	wg.Add(1)

	go func() {
		wg.Done()
		wg.Add(1)
	}()

	wg.Wait()
}

+++++++++++++++++++++++++++++++++++++++++++++++
error is:
panic: sync: WaitGroup is reused before previous Wait has returned


Atomics:
when you have 2 goroutines and some variables are share between them and in goroutines you read or write them, its Race Condition that happend!

Race Condition:
when a variable is shared between some goroutines and in each of them the variable value change (at same time some goroutines can read and write the variable) and at the end, the value is different in each time of running code:
+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"sync"
)

type request func()

func main() {
	var counter int32
	var wg sync.WaitGroup

	wg.Add(4)

	go func() {
		defer wg.Done()
		counter += 10
	}()

	go func() {
		defer wg.Done()
		counter -= 15
	}()

	go func() {
		defer wg.Done()
		counter = 100
	}()

	go func() {
		defer wg.Done()
		counter = 0
	}()

	wg.Wait()

	fmt.Println(counter)
}

+++++++++++++++++++++++++++++++++++++++++++++++
counter value is different in each time of execution!

we can change above code with atomic!
+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"sync"
	"sync/atomic"
)

type request func()

func main() {
	var counter int32
	var wg sync.WaitGroup

	wg.Add(4)

	go func() {
		defer wg.Done()
		atomic.StoreInt32(&counter, 10)
	}()

	go func() {
		defer wg.Done()
		atomic.StoreInt32(&counter, -15)
	}()

	go func() {
		defer wg.Done()
		atomic.StoreInt32(&counter, 100)
	}()

	go func() {
		defer wg.Done()
		atomic.StoreInt32(&counter, 0)
	}()

	wg.Wait()

	fmt.Println(counter)
}

+++++++++++++++++++++++++++++++++++++++++++++++
counter value is different in each time of execution!

atomic functions:

Store atomically stores val into *addr:

	func StoreInt32(addr *int32, val int32)
	func StoreInt64(addr *int64, val int64)
	func StoreUint32(addr *uint32, val uint32)
	func StoreUint64(addr *uint64, val uint64)
	func StoreUintptr(addr *uintptr, val uintptr)
	func StorePointer(addr *unsafe.Pointer, val unsafe.Pointer)

Load atomically loads *addr:

	func LoadInt32(addr *int32) (val int32)
	func LoadInt64(addr *int64) (val int64)
	func LoadUint32(addr *uint32) (val uint32)
	func LoadUint64(addr *uint64) (val uint64)
	func LoadUintptr(addr *uintptr) (val uintptr)
	func LoadPointer(addr *unsafe.Pointer) (val unsafe.Pointer)

Add atomically adds delta to *addr and returns the new value:

	func AddInt32(addr *int32, delta int32) (new int32)
	func AddUint32(addr *uint32, delta uint32) (new uint32)
	func AddInt64(addr *int64, delta int64) (new int64)
	func AddUint64(addr *uint64, delta uint64) (new uint64)
	func AddUintptr(addr *uintptr, delta uintptr) (new uintptr)

Swap atomically stores new into *addr and returns the previous *addr value:

	func SwapInt32(addr *int32, new int32) (old int32)
	func SwapInt64(addr *int64, new int64) (old int64)
	func SwapUint32(addr *uint32, new uint32) (old uint32)
	func SwapUint64(addr *uint64, new uint64) (old uint64)
	func SwapUintptr(addr *uintptr, new uintptr) (old uintptr)
	func SwapPointer(addr *unsafe.Pointer, new unsafe.Pointer) (old unsafe.Pointer)

CompareAndSwap executes the compare-and-swap operation for an int32 value:

	func CompareAndSwapInt32(addr *int32, old, new int32) (swapped bool)
	func CompareAndSwapInt64(addr *int64, old, new int64) (swapped bool)
	func CompareAndSwapUint32(addr *uint32, old, new uint32) (swapped bool)
	func CompareAndSwapUint64(addr *uint64, old, new uint64) (swapped bool)
	func CompareAndSwapUintptr(addr *uintptr, old, new uintptr) (swapped bool)
	func CompareAndSwapPointer(addr *unsafe.Pointer, old, new unsafe.Pointer) (swapped bool)


we can use atomic for different types by "atomic.Value":
+++++++++++++++++++++++++++++++++++++++++++++++

package main

import (
	"fmt"
	"log"
	"sync"
	"sync/atomic"
)

type Config struct {
	a []int
}

func main() {
	var wg sync.WaitGroup
	var v atomic.Value
	// to avoid panics when we do type assertion
	v.Store(Config{a: []int{}})

	// writer
	go func() {
		var i int
		for {
			i++
			cfg := Config{
				a: []int{i + 1, i + 2, i + 3, i + 4, i + 5},
			}
			v.Store(cfg)
		}
	}()

	// reader
	wg.Add(5)
	for i := 0; i < 5; i++ {
		go func() {
			defer wg.Done()
			// we're gonna get a panic this way
			// cfg := v.Load().(Config)
			cfg, ok := v.Load().(Config)
			if !ok {
				log.Fatalf("received different type: %T", cfg)
			}
			fmt.Println("cfg", cfg)
		}()
	}
	wg.Wait()
}

+++++++++++++++++++++++++++++++++++++++++++++++
store type must be same in program.
if store nil, you get Panic!