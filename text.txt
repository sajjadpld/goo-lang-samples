command:
    go mod init <module-path>

    create a new module
    module path can be a repository path like github/sajjadpld/test

    it make go.mod file


-------------------------------------------------------------------------------

all our code must be in a package.
in go files at the begining add this:

package main

the first statment in Go file must be package name.

--------------------------------------------------------------------------------

func main(){}

this is a Go project entery point.

a application must have a main function or an entery point only

--------------------------------------------------------------------------------

for importing packages use:

import "fmt"

or

import (
    fmt
)

now we imported fmt package

------------------------------------------------------------------------------------

a package is a collection of source files

---------------------------------------------------------------------------------

for running a Go file, we must run below command:
go run file_name.go

-------------------------------------------------------------------------------------

a simple hello world app

package main

import "fmt"

func main(){
	fmt.Println("hello world")
}


-----------------------------------------------------------------------------------------

variable declaration:

var name = "sajjad"

or

name := "sajjad"

var i, j = 1, 2
or
var i, j int = 1, 2
or
c, python, java := true, false, "no!"

or this way:
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
package main

import (
	"fmt"
	"math/cmplx"
)

var (
	ToBe bool = false
	MaxInt uint64 = 1<<64 - 1
	Z 	complex128 = cmplx.Sqrt(-5 + 12i) 
)


func main (){
	fmt.Printf("Type: %T Value %v \n", ToBe, ToBe)
	fmt.Printf("Type: %T Value %v \n", MaxInt, MaxInt)
	fmt.Printf("Type: %T Value %v \n", Z, Z)
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

------------------------------------------------------------------------------------------

variables and imported package must be use, if you dont use them, you get compile error

------------------------------------------------------------------------------------------

declar a constant:

const age = 24

Constants can be character, string, boolean, or numeric values.

Constants cannot be declared using the := syntax.

const (
	c1 = 24
	c2 = 85
)

--------------------------------------------------------------------------------------------

sample code for formatting output:

++++++++++++++++++++++++++
package main

import "fmt"

func main() {

	var name = "sajjad"
	family := "PLD"

	const age = 24

	fmt.Printf("Hi, my name is %v and my last name is %v, im %v years old", name, family, age)
}
+++++++++++++++++++++++++++++++

output is :
Hi, my name is sajjad and my last name is PLD, im 24 years old

--------------------------------------------------------------------------------------------

for initial an variable for later, we must declare the variable type:

	var fatherName string

	fatherName = "Mahmoud"

	fmt.Println(fatherName)

--------------------------------------------------------------------------------------------

for print variable type:

fmt.Printf("the type of fatherName is %T\n", fatherName)

%T is for getting variable Type

--------------------------------------------------------------------------------------------------

you can write these too:

var v1 int = 85
const c1 string = "sajjad"

these are as same as below:

var v1 = 85
const c1 = "sajjad"

or for var is:
v1 := 85

-----------------------------------------------------------------------------------------------------

compare to Java data type:

Go          Java
int8    =>  byte
int16    =>  short
int32    =>  int
int64    =>  long

Go          Java
uint8    =>  ubyte
uint16    =>  ushort
uint32    =>  uint
uint64    =>  ulong

int and uint are depend on system architect, if system is 32 bit, it's 32 and if 64 bit, it's 64

-----------------------------------------------------------------------------------------------------

pointers in Go

	var fatherName string

	fatherName = "Mahmoud"

	fmt.Println(fatherName)

	fmt.Println(&fatherName)

variable address to its value in memory (pointer) in Go is "&"

the output is:
Mahmoud
0xc000046290

--------------------------------------------------------------------------------------------------------

for getting user input sample code:

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
package main

import "fmt"

func main(){
	var gfName string
	fmt.Scan(&gfName)

	fmt.Printf("your gir friend name is %v", gfName)
}
++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

---------------------------------------------------------------------------------------------------------

in Go arrays are fixed size

for declare an arraye use this:
++++++++++++++++++++++++++++++++++++++++++++++++
	var books = [3]string {"a","b","c"}

	fmt.Println(books)
+++++++++++++++++++++++++++++++++++++++++++++++++

the output is :
[a b c]

---------------------------------------------------------------------------------------------------------

for declaring empty array and fill array index use this:
+++++++++++++++++++++++++++++++++++++++++++++
	var books [3]string

	books[0] = "a"
	books[1] = "b"
	books[2] = "c"

	fmt.Println(books)
+++++++++++++++++++++++++++++++++++++++++++++

the output is :
[a b c]

-----------------------------------------------------------------------------------------------------------

for getting arraye size or length use this:

len(array)


this function is use for array and slice and strings.

-----------------------------------------------------------------------------------------------------------

when we dont know the size of the array for declaration array, we can use slice.
slice basicly is an abstraction of anj array, so it uses the array type under the hood but has dynamic size.

++++++++++++++++++++++++++++++++++++++++++++++++++++++
	var books []string

	books = append(books, "a")
	books = append(books, "b")
	books = append(books, "c")

	fmt.Println(books)
	fmt.Println(books[0])
	fmt.Println(len(books))
+++++++++++++++++++++++++++++++++++++++++++++++++++++++

or use this instead of first line:

books := []string{}

-----------------------------------------------------------------------------------------------------------------

in Go we jus have "for" for loop.
no "while", "do while" and "foreach"!

for declar a simple loop:
+++++++++++++++++++++++++++++++++
	sum := 0
	for i := 0; i < 10; i++ {
		sum += i
	}
	fmt.Println(sum)
+++++++++++++++++++++++++++++++++

for declare an infinite loop:

++++++++++++++++++++++++++++++++++++
	for {
		fmt.Println("line")
	}
++++++++++++++++++++++++++++++++++++

condition in loop:

+++++++++++++++++++++++++++++++++++++

	for condition {
		//code
	}
++++++++++++++++++++++++++++++++++++
sample:
+++++++++++++++++++++++++++++++++++++
	sum := 1
	for ; sum < 1000; {
		sum += sum
	}
	fmt.Println(sum)
+++++++++++++++++++++++++++++++++++++
or
+++++++++++++++++++++++++++++++++++++++++
	sum := 1
	for sum < 1000 {
		sum += sum
	}
	fmt.Println(sum)
+++++++++++++++++++++++++++++++++++++++++

----------------------------------------------------------------------------------------------------------------

"rage" iterates over elements for different data structures (so not only arrayes and slices). for arrayes and slices, "range" provides the "index" and "value" for each element.

+++++++++++++++++++++++++
	var books = [8]string {"a", "b","c", "d","e", "f","g", "h"}

	for index, value := range books {
		fmt.Println(index, value)
	}
++++++++++++++++++++++++++++

the output is :
0 a
1 b
2 c
3 d
4 e
5 f
6 g
7 h


you can ignore unuse variable:

+++++++++++++++++++++++++
	var books = [8]string {"a", "b","c", "d","e", "f","g", "h"}

	for _, value := range books {
		fmt.Println(value)
	}
++++++++++++++++++++++++++++

or

+++++++++++++++++++++++++
	var books = [8]string {"a", "b","c", "d","e", "f","g", "h"}

	for index, _ := range books {
		fmt.Println(index)
	}
++++++++++++++++++++++++++++

------------------------------------------------------------------------------------------------------------------------

strings.Fields("str with space")

it spilite string by spaces and return an array

++++++++++++++++++++++++++++++++++++++++++++++++++++
package main

import (
	"fmt"
	"strings"
)

func main() {
	str := "my name is sajjad"

	fmt.Println(strings.Fields(str))
}
++++++++++++++++++++++++++++++++++++++++++++++++++
the output is :
[my name is sajjad]

---------------------------------------------------------------------------------------------------------------------------

condition:

if condition {
	//code
} else if condition {
	//code
} else {
	//code
}


Like for, the if statement can start with a short statement to execute before the condition.

Variables declared by the statement are only in scope until the end of the if.

+++++++++++++++++++++++++++++++++++++++++++++
func pow(x, n, lim float64) float64 {
	if v := math.Pow(x, n); v < lim {
		return v
	}
	return lim
}
+++++++++++++++++++++++++++++++++++++++++++++


-----------------------------------------------------------------------------------------------------------------------------------


checking string contains and another string:

+++++++++++++++++++++++++++++++++
package main

import (
	"fmt"
	"strings"
)

func main() {
	str := "my name is sajjad"

	fmt.Println(strings.Contains(str, "sajjad"))
}
+++++++++++++++++++++++++++++++++++++++++++++

----------------------------------------------------------------------------------------------------------------------------------

switch case:

switch variable {
	case expretion:
		//code
	case expretion:
		//code
	case expretion:
		//code
	case expretion:
		//code
	case expretion:
		//code
	default:
		//code
}

switch city {
	case "city1":
		//code
	case "city2", "city3":
		//code this is ||
	case "city4", "city5":
		//code this is ||
	case "city6":
		//code
	default:
		//code
}

Switch cases evaluate cases from top to bottom, stopping when a case succeeds.

-----------------------------------------------------------------------------------------------------------------

function:

with no param:

+++++++++++++++++++++++++++++
func fn(){
	//code
}
+++++++++++++++++++++++++++++
use:
fn()

with string param:
+++++++++++++++++++++++++++++
func fn(p1 string){
	fmt.Println(p1)
}
+++++++++++++++++++++++++++++
use:
fn("sajjad")

with arraye param:
+++++++++++++++++++++++++++++
func fn(arr []int){
	fmt.Println(arr)
}
++++++++++++++++++++++++++++
use:
var arr = [5]int {1,2,3,4,5}
fn(arr)

with return:
+++++++++++++++++
func fn() string{
	str := "sajjad"

	return str
}
++++++++++++++++++
use:
str := fn()

return multiple values:
++++++++++++++++++++++++++
func fn() (int, string){
	in := 24
	str := "sajjad"

	return in, str
}
++++++++++++++++++++++++
use:
in, st := fn()

-------------------------------------------------------------------------

package level variables are variables that declared in package (not function) and can access in all functions:

++++++++++++++++++++++++
package main

import (
	"fmt"
)

var name string = "sajjad"

func main() {
	fmt.Println(name)
}
+++++++++++++++++++++++++++++

define variables as "local" as possible.

-------------------------------------------------------------------------------

packages:

Go programes are orgnized into packages.
A package is a collection of Go files.

Variables and functions defiened outside any function (package level variables) can be accessed in all other files within the same package.

sample:

helper.go:
++++++++++++++++++
package main

import "strings"

func validateEmain() bool{
	return strings.Contains(email, "@")
}
+++++++++++++++++++

main.go:
+++++++++++++++++++
package main

import (
	"fmt"
)

var email string = "sajjad@gmailcom"

func main() {
	fmt.Println(validateEmain())
}
+++++++++++++++++++++++

for run project:
go run main.go helper.go
or
go run .

this sample was for same named package(main) or same package.
for multi package we must do this:

run this:
go mod init <module-path>

it makes go.mod file and <module-path> is or module name and for importing we use its name.

for make a variable or function public in Go, we must make first letter of the name captal, like:
func validateEmain(){...}	=>	func ValidateEmain(){...}.
put package files in same name directory.

now the structure is:

go.mod:
++++++++++++++++++++++++++
module booking-app

go 1.13
++++++++++++++++++++++++++

helper/helper.go
+++++++++++++++++++++++++++
package helper

import "strings"

func ValidateEmain(email string) bool{
	return strings.Contains(email, "@")
}
+++++++++++++++++++++++++++

main.go
++++++++++++++++++++++++++
package main

import (
	"fmt"
	"goo-lang-samples/helper"
)

var email string = "sajjad@gmailcom"

func main() {
	fmt.Println(helper.ValidateEmain(email))
}
++++++++++++++++++++++++++

-----------------------------------------------------------------------

variable scopes:

we declare variables in 3 mode:
local
package
global

local: 
we declar variables in a function and can be used only in that function.
we declar variables in a block of code like for, if, else and can be used only in that block.

package:
we declar variables outof function, in package and can be used in all the same package.

global:
we declar variables outside all functions (package variable) with uppercase first letter and this can be used everywhere across all packages.

--------------------------------------------------------------------------

maps:

unique keys to value.
all keys have the same data type.
all values have the same data type.

+++++++++++++++++++++++++++++++++++++
var userData = map[string]string
+++++++++++++++++++++++++++++++++++++

map[string]	=>	the key data type is string
string	=>	the value data type is string

for create empty map:
++++++++++++++++++++++++++++++++++++++++
var userData = make(map[string]string)
++++++++++++++++++++++++++++++++++++++++

for adding do this:
++++++++++++++++++++++++++++++++++++++++++
	var userData = make(map[string]string)

	userData["userName"] = "sajjadpld"
	userData["password"] = "1234"

	fmt.Println(userData)
++++++++++++++++++++++++++++++++++++++++++

the output is:
map[password:1234 userName:sajjadpld]

for gett specific key:
++++++++++++++++++++++++++++++++++++
fmt.Println(userData["userName"])
+++++++++++++++++++++++++++++++++++++

for declare an array of map:
++++++++++++++++++++++++++++++++++++
var books = make([]map[string]string, 0)
++++++++++++++++++++++++++++++++++++
the make function second param can be any number, because it makes slice and the size of slice increse.

--------------------------------------------------------------------------------------------------------------

struct:
struct is like class OOP languages but its different with it.
it's like a lighweight class wich dosen't support inheritance.
it can contains mixed data types and define a structure of data.

++++++++++++++++++++++++++++++++
package main

import (
	"fmt"
)

type userData struct {
	name  string
	email string
}

func main() {
	data := userData{"sajjad", "1234"}
	fmt.Println(data)
}
++++++++++++++++++++++++++++++++

for initiate new struct you can use:
+++++++++++++++++++++++++++++++++
data := userData{"sajjad", "1234"}
+++++++++++++++++++++++++++++++++
or
+++++++++++++++++++++++++++++++++++
data := userData{name: "sajjad", email: "1234"}
+++++++++++++++++++++++++++++++++++

for making an array of structs you can use like maps:
+++++++++++++++++++++++++++++++++++
var books = make([]userData, 0)
+++++++++++++++++++++++++++++++++++

for getting an item from struct do this:
++++++++++++++++++++++++++++++++
fmt.Println(data.email)
++++++++++++++++++++++++++++++++

for editing struct do:
++++++++++++++++++++++++++++++++
data.email = "email@mm.com"
++++++++++++++++++++++++++++++++

-----------------------------------------------------------------------------------------------------

for installing new package run below command:

go get <package-address>

-----------------------------------------------------------------------------------------------------

multiple string lines in go:

str := `Select count(e.id) as count
    FROM event AS e
	INNER JOIN event_participants AS ep ON e.id = ep.eventFK
	LEFT JOIN participant AS p ON ep.participantFK = p.id
	LEFT JOIN tournament_stage AS ts ON ts.id = e.tournament_stageFK
	LEFT JOIN tournament AS t ON t.id = ts.tournamentFK
	LEFT JOIN tournament_template AS tt ON tt.id = t.tournament_templateFK
	LEFT JOIN property AS e_prop ON e_prop.objectFK = e.id AND e_prop.object = "event" AND e_prop.type = "metadata"
	LEFT JOIN lineup AS l ON ep.id = l.event_participantsFK
    WHERE
	tt.sportFK = 1 AND
	e.status_type = "finished" AND
    e.del = "no" AND
    p.del = "no"
    `

-----------------------------------------------------------------------------------------------------
defer:

A defer statement defers the execution of a function until the surrounding function returns.

The deferred call's arguments are evaluated immediately, but the function call is not executed until the surrounding function returns.

+++++++++++++++++++++++++++++++++++++++++++++++++
package main

import "fmt"

func main() {
	defer fmt.Println("world")

	fmt.Println("hello")
}
+++++++++++++++++++++++++++++++++++++++++++++++++
output:
hello
world


Deferred function calls are pushed onto a stack. When a function returns, its deferred calls are executed in last-in-first-out order.
++++++++++++++++++++++++++++++++++++++++++++++++
package main

import "fmt"

func main() {
	fmt.Println("counting")

	for i := 0; i < 10; i++ {
		defer fmt.Println(i)
	}

	fmt.Println("done")
}
++++++++++++++++++++++++++++++++++++++++++++++++
output:
counting
done
9
8
7
6
5
4
3
2
1
0

--------------------------------------------------------------------------------------------------------------------

pointers:

A pointer holds the memory address of a value.
The type *T is a pointer to a T value. for function params we can use this:
++++++++++++++++++++++++++++++++++++++
package main

import "fmt"

func ptr(p *int) {
	*p = 24
}

func main() {
	i := 42

	fmt.Println(i)
	ptr(&i)
	fmt.Println(i)
}
++++++++++++++++++++++++++++++++++++++
output:
42
24

The & operator generates a pointer to its operand. & return the variable memory address and we can put it in a variable and with * we can get the value of the memory address.
+++++++++++++++++++++++++++++++++++++++
	i, j := 42, 2701

	p := &i         // point to i
	fmt.Println(*p) // read i through the pointer
	fmt.Println(p)
	*p = 21        // set i through the pointer
	fmt.Println(i) // see the new value of i

	p = &j         // point to j
	*p = *p / 37   // divide j through the pointer
	fmt.Println(j) // see the new value of j
+++++++++++++++++++++++++++++++++++++++
output:
42
0xc0000140b0
21
73

we can use pointer for struct:
++++++++++++++++++++++++++++++++++++++++++++++++++
package main

import "fmt"

type Vertex struct {
	X int
	Y int
}

func main() {
	v := Vertex{1, 2}
	p := &v
	p.X = 3
	fmt.Println(v)
}
++++++++++++++++++++++++++++++++++++++++++++++++++
output:
{3 2}

instead if p.X = 3 we can use (*p).X = 3.
To access the field X of a struct when we have the struct pointer p we could write (*p).X. 
However, that notation is cumbersome, so the language permits us instead to write just p.X, without the explicit dereference.
